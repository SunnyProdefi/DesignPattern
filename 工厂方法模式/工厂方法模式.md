### 工厂方法模式（Factory Method Pattern）

#### 1. **概述**
工厂方法模式是一种**创建型模式**，它定义了一个创建对象的接口，但由子类决定实例化哪一个类。它让类的实例化推迟到子类中进行，从而实现了解耦。

#### 2. **结构**
工厂方法模式由以下几个关键角色组成：
- **抽象产品（Product）**：定义工厂方法创建的对象类型。
- **具体产品（Concrete Product）**：实现具体的产品类。
- **抽象工厂（Creator）**：声明工厂方法，用于返回**抽象产品**类型的对象。
- **具体工厂（Concrete Creator）**：实现工厂方法，返回具体的产品实例。

#### 3. **UML 类图**
```
            ┌───────────────────┐
            │   Creator         │
            │ ────────────────  │
            │ +factoryMethod()  │
            └───────────────────┘
                     ▲
                     │
    ┌────────────────┴────────────────┐
    │                                 │
┌─────────────   ──┐               ┌────────────────  ┐
│ ConcreteCreatorA │               │ ConcreteCreatorB │
│ ───────────────  │               │ ───────────────  │
│ +factoryMethod() │               │ +factoryMethod() │
└─────────────   ──┘               └────────────────  ┘
        ▲                                   ▲
        │                                   │
┌──────────────┐                    ┌──────────────┐
│ ProductA     │                    │ ProductB     │
└──────────────┘                    └──────────────┘
```

#### 4. **代码示例（C++ 实现）**
```cpp
#include <iostream>
#include <memory>

// 抽象产品类
class Product {
public:
    virtual void use() = 0;
    virtual ~Product() = default;
};

// 具体产品 A
class ConcreteProductA : public Product {
public:
    void use() override {
        std::cout << "Using ConcreteProductA\n";
    }
};

// 具体产品 B
class ConcreteProductB : public Product {
public:
    void use() override {
        std::cout << "Using ConcreteProductB\n";
    }
};

// 抽象工厂类
class Creator {
public:
    virtual std::unique_ptr<Product> factoryMethod() = 0;
    virtual ~Creator() = default;
};

// 具体工厂 A
class ConcreteCreatorA : public Creator {
public:
    std::unique_ptr<Product> factoryMethod() override {
        return std::make_unique<ConcreteProductA>();
    }
};

// 具体工厂 B
class ConcreteCreatorB : public Creator {
public:
    std::unique_ptr<Product> factoryMethod() override {
        return std::make_unique<ConcreteProductB>();
    }
};

int main() {
    std::unique_ptr<Creator> creatorA = std::make_unique<ConcreteCreatorA>();
    std::unique_ptr<Product> productA = creatorA->factoryMethod();
    productA->use();

    std::unique_ptr<Creator> creatorB = std::make_unique<ConcreteCreatorB>();
    std::unique_ptr<Product> productB = creatorB->factoryMethod();
    productB->use();

    return 0;
}
```

#### 5. **优缺点**
**优点：**
- 符合**开闭原则**，可以通过增加具体工厂来扩展新产品，而无需修改已有代码。
- 符合**单一职责原则**，工厂负责创建对象，产品负责实现功能，职责分离。
- 代码的可维护性和可扩展性更强。

**缺点：**
- 需要额外定义工厂类，增加了代码复杂性。
- 如果产品种类很多，会导致大量的具体工厂类。

#### 6. **适用场景**
- 当创建对象的逻辑较复杂时（如涉及依赖注入、缓存、对象池）。
- 当需要屏蔽对象创建的细节，提高代码的灵活性和可扩展性。
- 当需要在运行时决定实例化哪种具体类。

### 7. **与简单工厂模式的对比**
| 比较项           | 工厂方法模式 | 简单工厂模式 |
|---------------|----------|----------|
| 工厂角色      | 抽象工厂+具体工厂 | 只有一个工厂类 |
| 代码扩展性    | 高（新增产品时不修改原代码） | 低（需要修改工厂类） |
| 适用场景      | 需要灵活扩展产品类型 | 产品种类较少，工厂逻辑简单 |

工厂方法模式虽然比简单工厂模式复杂一些，但它提供了更好的**可扩展性和维护性**，在需要支持多种产品类型且可能有扩展需求的情况下，使用工厂方法模式是更好的选择。